// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "forge-std/Test.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/**
 * @title CompleteOpenTest
 * @notice 完整的开仓测试 - 测试不同代币和场景
 */
contract CompleteOpenTest is Test {
    // Sepolia 合约地址
    address constant POOL_MANAGER = 0xBb644076500Ea106d9029B382C4d49f56225cB82;
    address constant NEW_AAVE_POOL = 0x3C67A6Fea47A00f2Ce6D3c1D1f170558d2b091AB;
    address constant FXUSD = 0x085a1b6da46aE375b35Dea9920a276Ef571E209c;
    address constant USDC = 0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238;
    address constant MOCK_ORACLE = 0x0347f7d0952b3c55E276D42b9e2950Cc0523d787;
    address constant ROUTER = 0xB8B3e6C7D0f0A9754F383107A6CCEDD8F19343Ec;
    
    IERC20 usdc;
    IERC20 fxUSD;
    address user;
    
    function setUp() public {
        // Fork Sepolia
        vm.createSelectFork(vm.envString("SEPOLIA_RPC_URL"));
        
        // Setup contracts
        usdc = IERC20(USDC);
        fxUSD = IERC20(FXUSD);
        
        // Setup user with private key
        user = vm.addr(vm.envUint("PRIVATE_KEY"));
        
        console.log("====================================");
        console.log("Complete Open Position Test");
        console.log("====================================");
        console.log("Network: Sepolia (Fork)");
        console.log("User:", user);
        console.log("USDC Balance (USDC):", usdc.balanceOf(user) / 1e6);
        console.log("fxUSD Balance (fxUSD):", fxUSD.balanceOf(user) / 1e18);
        console.log("");
    }
    
    function test_1_CheckPoolSetup() public view {
        console.log("====================================");
        console.log("Test 1: Check Pool Setup");
        console.log("====================================");
        console.log("");
        
        // Check pool registration
        (bool success, bytes memory data) = POOL_MANAGER.staticcall(
            abi.encodeWithSignature("getPoolInfo(address)", NEW_AAVE_POOL)
        );
        
        assertTrue(success, "Pool should be registered");
        
        (address rewarder, address gauge, uint256 collCap, uint256 debtCap) = 
            abi.decode(data, (address, address, uint256, uint256));
        
        console.log("Pool Info:");
        console.log("  Rewarder:", rewarder);
        console.log("  Gauge:", gauge);
        console.log("  Collateral Cap (USDC):", collCap / 1e6);
        console.log("  Debt Cap (fxUSD):", debtCap / 1e18);
        console.log("");
        
        assertGt(debtCap, 0, "Debt capacity should be set");
        
        console.log("OK: Pool is properly registered");
        console.log("");
    }
    
    function test_2_CheckOracle() public view {
        console.log("====================================");
        console.log("Test 2: Check Price Oracle");
        console.log("====================================");
        console.log("");
        
        // Check pool oracle
        (bool success1, bytes memory data1) = NEW_AAVE_POOL.staticcall(
            abi.encodeWithSignature("priceOracle()")
        );
        
        assertTrue(success1, "Should get oracle address");
        address oracle = abi.decode(data1, (address));
        
        console.log("Pool Oracle:", oracle);
        console.log("Expected:", MOCK_ORACLE);
        
        assertEq(oracle, MOCK_ORACLE, "Oracle should be MockOracle");
        
        // Check oracle price
        (bool success2, bytes memory data2) = MOCK_ORACLE.staticcall(
            abi.encodeWithSignature("getPrice()")
        );
        
        assertTrue(success2, "Should get price");
        (uint256 anchor, uint256 min, uint256 max) = 
            abi.decode(data2, (uint256, uint256, uint256));
        
        console.log("Oracle Prices (USD):");
        console.log("  Anchor:", anchor / 1e18);
        console.log("  Min:", min / 1e18);
        console.log("  Max:", max / 1e18);
        console.log("");
        
        assertEq(anchor, 1e18, "Price should be 1.0 USD");
        
        console.log("OK: Oracle is working correctly");
        console.log("");
    }
    
    function test_3_CheckPermissions() public view {
        console.log("====================================");
        console.log("Test 3: Check Permissions");
        console.log("====================================");
        console.log("");
        
        bytes32 POOL_MANAGER_ROLE = keccak256("POOL_MANAGER_ROLE");
        
        // Check FxUSD
        (bool success1, bytes memory data1) = FXUSD.staticcall(
            abi.encodeWithSignature("hasRole(bytes32,address)", POOL_MANAGER_ROLE, POOL_MANAGER)
        );
        
        if (success1) {
            bool hasRole = abi.decode(data1, (bool));
            console.log("PoolManager has POOL_MANAGER_ROLE on FxUSD:", hasRole);
            assertTrue(hasRole, "PoolManager should have role on FxUSD");
        }
        
        // Check New Pool
        (bool success2, bytes memory data2) = NEW_AAVE_POOL.staticcall(
            abi.encodeWithSignature("hasRole(bytes32,address)", POOL_MANAGER_ROLE, POOL_MANAGER)
        );
        
        if (success2) {
            bool hasRole = abi.decode(data2, (bool));
            console.log("PoolManager has POOL_MANAGER_ROLE on New Pool:", hasRole);
            assertTrue(hasRole, "PoolManager should have role on Pool");
        }
        
        console.log("");
        console.log("OK: All permissions configured");
        console.log("");
    }
    
    function test_4_OpenPosition_SmallAmount() public {
        console.log("====================================");
        console.log("Test 4: Open Position (1 USDC)");
        console.log("====================================");
        console.log("");
        
        uint256 usdcBefore = usdc.balanceOf(user);
        uint256 fxUSDBefore = fxUSD.balanceOf(user);
        
        console.log("Before:");
        console.log("  USDC:", usdcBefore / 1e6);
        console.log("  fxUSD:", fxUSDBefore / 1e18);
        console.log("");
        
        if (usdcBefore == 0) {
            console.log("SKIP: No USDC balance");
            return;
        }
        
        uint256 collateral = 1e6;  // 1 USDC
        uint256 debt = 5e17;       // 0.5 fxUSD
        uint256 positionId = 100;
        
        console.log("Parameters:");
        console.log("  Collateral (USDC):", collateral / 1e6);
        console.log("  Debt (fxUSD):", debt / 1e18);
        console.log("  Position ID:", positionId);
        console.log("");
        
        vm.startPrank(user);
        
        // Approve if needed
        if (usdc.allowance(user, POOL_MANAGER) < collateral) {
            usdc.approve(POOL_MANAGER, type(uint256).max);
            console.log("USDC approved");
        }
        
        // Try to open position
        console.log("Opening position...");
        
        (bool success, bytes memory returnData) = POOL_MANAGER.call(
            abi.encodeWithSignature(
                "operate(address,uint256,int256,int256)",
                NEW_AAVE_POOL,
                positionId,
                int256(collateral),
                int256(debt)
            )
        );
        
        if (success) {
            console.log("SUCCESS!");
            console.log("");
            
            uint256 usdcAfter = usdc.balanceOf(user);
            uint256 fxUSDAfter = fxUSD.balanceOf(user);
            
            console.log("After:");
            console.log("  USDC:", usdcAfter / 1e6);
            console.log("  fxUSD:", fxUSDAfter / 1e18);
            console.log("");
            console.log("Changes:");
            console.log("  USDC Spent:", (usdcBefore - usdcAfter) / 1e6);
            console.log("  fxUSD Received:", (fxUSDAfter - fxUSDBefore) / 1e18);
            console.log("");
            
            // Verify balances changed
            assertLt(usdcAfter, usdcBefore, "USDC should decrease");
            assertGt(fxUSDAfter, fxUSDBefore, "fxUSD should increase");
            
            console.log("OK: Position opened successfully!");
        } else {
            console.log("FAILED!");
            console.log("Return data:");
            console.logBytes(returnData);
            console.log("");
            
            // Try to decode error
            if (returnData.length > 0) {
                if (returnData.length >= 4) {
                    bytes4 errorSelector = bytes4(returnData);
                    console.log("Error selector:");
                    console.logBytes4(errorSelector);
                }
            }
            
            revert("Position opening failed");
        }
        
        vm.stopPrank();
        console.log("");
    }
    
    function test_5_OpenPosition_LargeAmount() public {
        console.log("====================================");
        console.log("Test 5: Open Position (10 USDC)");
        console.log("====================================");
        console.log("");
        
        uint256 usdcBefore = usdc.balanceOf(user);
        
        if (usdcBefore < 10e6) {
            console.log("SKIP: Insufficient USDC (need 10)");
            return;
        }
        
        uint256 collateral = 10e6;  // 10 USDC
        uint256 debt = 5e18;        // 5 fxUSD
        uint256 positionId = 101;
        
        console.log("Parameters:");
        console.log("  Collateral (USDC):", collateral / 1e6);
        console.log("  Debt (fxUSD):", debt / 1e18);
        console.log("");
        
        vm.startPrank(user);
        
        (bool success,) = POOL_MANAGER.call(
            abi.encodeWithSignature(
                "operate(address,uint256,int256,int256)",
                NEW_AAVE_POOL,
                positionId,
                int256(collateral),
                int256(debt)
            )
        );
        
        if (success) {
            console.log("SUCCESS: Large position opened!");
            
            uint256 fxUSDReceived = fxUSD.balanceOf(user);
            console.log("fxUSD Received:", fxUSDReceived / 1e18);
            console.log("");
        } else {
            console.log("FAILED: Could not open large position");
        }
        
        vm.stopPrank();
        console.log("");
    }
    
    function test_6_MultiplePositions() public {
        console.log("====================================");
        console.log("Test 6: Open Multiple Positions");
        console.log("====================================");
        console.log("");
        
        uint256 usdcBefore = usdc.balanceOf(user);
        
        if (usdcBefore < 3e6) {
            console.log("SKIP: Insufficient USDC (need 3)");
            return;
        }
        
        vm.startPrank(user);
        
        uint256[] memory positionIds = new uint256[](3);
        positionIds[0] = 200;
        positionIds[1] = 201;
        positionIds[2] = 202;
        
        for (uint256 i = 0; i < 3; i++) {
            console.log("Opening position", i + 1, "/3...");
            
            (bool success,) = POOL_MANAGER.call(
                abi.encodeWithSignature(
                    "operate(address,uint256,int256,int256)",
                    NEW_AAVE_POOL,
                    positionIds[i],
                    int256(1e6),  // 1 USDC each
                    int256(5e17)  // 0.5 fxUSD each
                )
            );
            
            if (success) {
                console.log("  OK: Position", positionIds[i], "opened");
            } else {
                console.log("  FAILED: Position", positionIds[i]);
                break;
            }
        }
        
        vm.stopPrank();
        console.log("");
    }
    
    function test_7_TestRouter() public view {
        console.log("====================================");
        console.log("Test 7: Router Functionality");
        console.log("====================================");
        console.log("");
        
        // Test DiamondLoupe
        (bool success, bytes memory data) = ROUTER.staticcall(
            abi.encodeWithSignature("facets()")
        );
        
        assertTrue(success, "Should get facets");
        
        console.log("Router Facets:");
        // Decode facet info
        // Note: This is a complex struct, just check success
        console.log("  Total facets retrieved successfully");
        console.log("");
        
        console.log("OK: Router is functional");
        console.log("");
    }
    
    function test_8_BuyDifferentAmounts() public {
        console.log("====================================");
        console.log("Test 8: Buy Different Amounts of fxUSD");
        console.log("====================================");
        console.log("");
        
        uint256 usdcBalance = usdc.balanceOf(user);
        
        if (usdcBalance < 5e6) {
            console.log("SKIP: Insufficient USDC (need 5)");
            return;
        }
        
        vm.startPrank(user);
        
        // Test different debt amounts with same collateral
        uint256[3] memory debtAmounts = [
            uint256(3e17),  // 0.3 fxUSD (30% LTV)
            uint256(5e17),  // 0.5 fxUSD (50% LTV)
            uint256(7e17)   // 0.7 fxUSD (70% LTV)
        ];
        
        for (uint256 i = 0; i < debtAmounts.length; i++) {
            uint256 positionId = 300 + i;
            uint256 collateral = 1e6; // 1 USDC
            uint256 debt = debtAmounts[i];
            
            console.log("Test case - Debt (fxUSD):", debt / 1e18);
            console.log("  LTV (%):", (debt * 100) / (collateral * 1e12));
            
            uint256 fxUSDBefore = fxUSD.balanceOf(user);
            
            (bool success,) = POOL_MANAGER.call(
                abi.encodeWithSignature(
                    "operate(address,uint256,int256,int256)",
                    NEW_AAVE_POOL,
                    positionId,
                    int256(collateral),
                    int256(debt)
                )
            );
            
            if (success) {
                uint256 fxUSDAfter = fxUSD.balanceOf(user);
                uint256 received = fxUSDAfter - fxUSDBefore;
                console.log("  OK: Received", received / 1e18, "fxUSD");
                console.log("");
            } else {
                console.log("  FAILED at this LTV");
                console.log("");
            }
        }
        
        vm.stopPrank();
    }
    
    function test_9_CheckCollateralFunction() public view {
        console.log("====================================");
        console.log("Test 9: Debug collateral() Function");
        console.log("====================================");
        console.log("");
        
        console.log("Checking collateral() on new pool...");
        
        (bool success, bytes memory data) = NEW_AAVE_POOL.staticcall(
            abi.encodeWithSignature("collateral()")
        );
        
        if (success) {
            address collateral = abi.decode(data, (address));
            console.log("OK: collateral() =", collateral);
            console.log("Expected:", USDC);
            assertEq(collateral, USDC, "Collateral should be USDC");
        } else {
            console.log("FAILED: collateral() reverts");
            console.log("Error data:");
            console.logBytes(data);
            console.log("");
            console.log("This is why opening positions fail!");
        }
        
        console.log("");
    }
    
    function test_10_TryDirectPoolCall() public {
        console.log("====================================");
        console.log("Test 10: Try Direct Pool Interaction");
        console.log("====================================");
        console.log("");
        
        if (usdc.balanceOf(user) == 0) {
            console.log("SKIP: No USDC");
            return;
        }
        
        vm.startPrank(user);
        
        // Try calling pool.operate() directly (as PoolManager)
        console.log("WARNING: This will likely fail");
        console.log("Pools should only be called by PoolManager");
        console.log("");
        
        // Try anyway for diagnostic purposes
        (bool success,) = NEW_AAVE_POOL.call(
            abi.encodeWithSignature(
                "operate(address,uint256,int256,int256)",
                user,
                400,
                int256(1e6),
                int256(5e17)
            )
        );
        
        if (success) {
            console.log("Unexpected: Direct call succeeded!");
        } else {
            console.log("Expected: Direct call failed (onlyPoolManager)");
        }
        
        vm.stopPrank();
        console.log("");
    }
}

