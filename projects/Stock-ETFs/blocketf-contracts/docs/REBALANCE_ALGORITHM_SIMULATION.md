# Rebalance Algorithm Simulation

## 算法描述

基于权重缺口分配USDT预算的Rebalance算法：

```
1. 卖出over-weighted资产 → 收集USDT
2. 获取卖出后的最新权重
3. 计算每个under-weighted资产的权重缺口
4. 按权重缺口比例分配USDT
5. 执行买入，归还资产
```

## 场景1：标准Rebalance（3资产）

### 初始状态
```
资产组合：BTC, ETH, USDT
目标权重：40%, 30%, 30%
当前价格：BTC=$50,000, ETH=$3,000, USDT=$1

初始持仓：
- BTC: 0.5个 = $25,000 (50%)
- ETH: 5个 = $15,000 (30%)
- USDT: $10,000 (20%)
总价值：$50,000

当前权重：[5000, 3000, 2000] (basis points)
目标权重：[4000, 3000, 3000]
权重偏差：BTC超10%, USDT缺10%
```

### Core合约计算的rebalanceAmounts
```
BTC: +0.1个 (卖出$5,000)
ETH: 0 (保持不变)
USDT: -$5,000 (买入)
```

### Rebalancer执行流程

#### Phase 1: 卖出BTC
```
卖出: 0.1 BTC
假设滑点2%: 实际收到 = $5,000 * 0.98 = $4,900 USDT
totalUSDTCollected = $4,900
```

#### Phase 2: 卖出后获取最新权重
```
新持仓：
- BTC: 0.4个 = $20,000
- ETH: 5个 = $15,000
- USDT: $10,000 (原有) + $4,900 (卖出收入) = $14,900
总价值：$49,900 (滑点损失$100)

新的当前权重：
- BTC: $20,000 / $49,900 = 40.08% → 4008 bps
- ETH: $15,000 / $49,900 = 30.06% → 3006 bps
- USDT: $14,900 / $49,900 = 29.86% → 2986 bps

目标权重：[4000, 3000, 3000]
```

#### Phase 3: 计算权重缺口
```
amounts[0] = +0.1 BTC (卖单，跳过)
amounts[1] = 0 (不操作)
amounts[2] = -$5,000 (买单，但USDT不需要买)

实际上amounts[2]应该是负数表示要买入USDT，但USDT不需要swap
所以这个场景下totalWeightDeficit = 0，不执行买入
```

**⚠️ 发现问题1：USDT作为中间代币的特殊处理**

### 修正：场景1改为BTC/ETH再平衡

```
目标权重：50% BTC, 50% ETH
当前权重：60% BTC, 40% ETH

初始持仓：
- BTC: 0.6个 = $30,000 (60%)
- ETH: 4个 = $12,000 (40%)
总价值：$42,000

rebalanceAmounts:
- BTC: +0.1个 (卖出$5,000)
- ETH: -1.5个 (买入$4,500)
```

#### Phase 1: 卖出BTC → USDT
```
卖出: 0.1 BTC = $5,000
滑点2%: 收到 $4,900 USDT
```

#### Phase 2: 获取卖出后权重
```
持仓：
- BTC: 0.5个 = $25,000
- ETH: 4个 = $12,000
- USDT: $4,900 (临时持有)
总价值: $41,900

当前权重：
- BTC: $25,000 / $41,900 = 59.67% → 5967 bps
- ETH: $12,000 / $41,900 = 28.64% → 2864 bps

目标权重：
- BTC: 5000 bps
- ETH: 5000 bps
```

#### Phase 3: 计算权重缺口
```
BTC: amounts[0] > 0 → 跳过（已卖出）
ETH: amounts[1] < 0 → 计算缺口
  targetWeight[1] = 5000
  currentWeight[1] = 2864
  deficit = 5000 - 2864 = 2136 bps

totalWeightDeficit = 2136
```

#### Phase 4: 分配USDT并买入
```
ETH分配的USDT = $4,900 * (2136 / 2136) = $4,900

用$4,900买入ETH：
滑点2%: 实际买入 = $4,900 / $3,000 / 1.02 = 1.601 ETH
```

#### Phase 5: 最终状态
```
最终持仓：
- BTC: 0.5个 = $25,000
- ETH: 4 + 1.601 = 5.601个 = $16,803
总价值: $41,803 (总滑点损失: $42,000 - $41,803 = $197)

最终权重：
- BTC: $25,000 / $41,803 = 59.81% (目标50%)
- ETH: $16,803 / $41,803 = 40.19% (目标50%)

权重偏差：BTC仍超9.81%, ETH仍缺9.81%
```

**⚠️ 发现问题2：单次rebalance无法完全达到目标**

原因：
1. Core计算的卖出量基于初始权重
2. 但实际买入量受滑点影响
3. 一次rebalance只能部分缩小偏差

**✅ 这是正常的！Core合约会检查"权重偏差是否改善"，而不是"是否完全达标"**

---

## 场景2：多资产Rebalance（4资产）

### 初始状态
```
资产：BTC, ETH, BNB, USDT
目标权重：30%, 30%, 30%, 10%
价格：BTC=$50k, ETH=$3k, BNB=$500, USDT=$1

初始持仓：
- BTC: 0.6个 = $30,000 (50%)
- ETH: 3个 = $9,000 (15%)
- BNB: 20个 = $10,000 (16.67%)
- USDT: $11,000 (18.33%)
总价值: $60,000

当前权重：[5000, 1500, 1667, 1833]
目标权重：[3000, 3000, 3000, 1000]
```

### Core计算rebalanceAmounts
```
BTC: 超重20% → 卖出0.24个 = $12,000
ETH: 缺重15% → 买入$9,000
BNB: 缺重13.33% → 买入$8,000
USDT: 超重8.33% → 但作为中间币，实际不操作
```

简化：假设USDT通过卖出BTC补充

### Rebalancer执行

#### Phase 1: 卖出BTC
```
卖出: 0.24 BTC = $12,000
滑点2%: 收到 $11,760 USDT
```

#### Phase 2: 获取新权重
```
持仓：
- BTC: 0.36个 = $18,000
- ETH: 3个 = $9,000
- BNB: 20个 = $10,000
- USDT: $11,000 + $11,760 = $22,760
总价值: $59,760

当前权重：
- BTC: 30.12% → 3012 bps
- ETH: 15.06% → 1506 bps
- BNB: 16.74% → 1674 bps
- USDT: 38.08% → 3808 bps (临时高，因为刚卖完)
```

#### Phase 3: 计算权重缺口
```
ETH: target=3000, current=1506 → deficit = 1494 bps
BNB: target=3000, current=1674 → deficit = 1326 bps
USDT: target=1000, current=3808 → 超重，deficit = 0

totalWeightDeficit = 1494 + 1326 = 2820 bps
```

#### Phase 4: 按比例分配USDT
```
总USDT: $11,760

ETH分配: $11,760 * (1494 / 2820) = $6,234
BNB分配: $11,760 * (1326 / 2820) = $5,526

买入ETH: $6,234 / $3,000 / 1.02 = 2.037 ETH
买入BNB: $5,526 / $500 / 1.02 = 10.835 BNB
```

#### Phase 5: 最终状态
```
最终持仓：
- BTC: 0.36个 = $18,000
- ETH: 3 + 2.037 = 5.037个 = $15,111
- BNB: 20 + 10.835 = 30.835个 = $15,418
- USDT: $22,760 - $6,234 - $5,526 = $11,000
总价值: $59,529 (滑点损失: $471)

最终权重：
- BTC: 30.24% (目标30%) ✅
- ETH: 25.38% (目标30%) → 仍缺4.62%
- BNB: 25.90% (目标30%) → 仍缺4.10%
- USDT: 18.48% (目标10%) → 仍超8.48%

总权重偏差改善：
之前: |20%| + |15%| + |13.33%| + |8.33%| = 56.66%
之后: |0.24%| + |4.62%| + |4.10%| + |8.48%| = 17.44%
改善: 69.2% ✅
```

**✅ 算法有效：虽然未完全达标，但显著改善了权重分布**

---

## 场景3：极端情况 - 卖出后某资产已超标

### 初始状态
```
3资产：A, B, C
目标权重：40%, 40%, 20%
价格：A=$100, B=$100, C=$100

初始持仓：
- A: 50个 = $5,000 (50%)
- B: 30个 = $3,000 (30%)
- C: 20个 = $2,000 (20%)
总价值: $10,000

当前权重：[5000, 3000, 2000]
目标权重：[4000, 4000, 2000]
```

### Core计算
```
A: 超10% → 卖出10个 = $1,000
B: 缺10% → 买入$1,000
C: 正好
```

### Rebalancer执行

#### Phase 1: 卖出A
```
卖出: 10个A = $1,000
滑点5%: 收到 $950 USDT
```

#### Phase 2: 卖出后权重
```
持仓：
- A: 40个 = $4,000
- B: 30个 = $3,000
- C: 20个 = $2,000
- USDT: $950 (临时)
总价值: $9,950

当前权重：
- A: 40.20% → 4020 bps
- B: 30.15% → 3015 bps
- C: 20.10% → 2010 bps
- USDT: 9.55% → 955 bps (临时)
```

#### Phase 3: 计算缺口
```
B: target=4000, current=3015 → deficit = 985 bps
C: target=2000, current=2010 → 超重10bps, deficit = 0 ⚠️

totalWeightDeficit = 985
```

#### Phase 4: 买入
```
B分配: $950 * (985 / 985) = $950
买入B: $950 / $100 / 1.02 = 9.31个
```

#### Phase 5: 最终
```
持仓：
- A: 40个 = $4,000
- B: 30 + 9.31 = 39.31个 = $3,931
- C: 20个 = $2,000
总价值: $9,931

权重：
- A: 40.28% (目标40%) ✅
- B: 39.58% (目标40%) ✅ 接近
- C: 20.14% (目标20%) ✅

总偏差: 0.28% + 0.42% + 0.14% = 0.84% ✅ 优秀！
```

**✅ 算法处理得当：C资产微超后不再买入，避免过度调整**

---

## 场景4：压力测试 - 大滑点

### 场景设定
```
2资产：A, B
目标: 50%, 50%
初始: A=80%, B=20%
卖出A时遭遇20%滑点（极端市场条件）
```

### 执行
```
卖出: $3,000 A
滑点20%: 收到 $2,400 USDT

B的权重缺口: 30%
用$2,400买入B (滑点5%)
实际买入: $2,400 / 1.05 = $2,286价值的B

最终: A=77.14%, B=22.86%
偏差改善: 60% → 54.28% (改善9.5%)
```

**⚠️ 大滑点场景下改善有限，但：**
1. Core合约的`maxTotalValueLossBps`会检测到20%损失 → revert ✅
2. 算法本身逻辑正确，是市场条件不满足rebalance条件

---

## 算法验证结论

### ✅ 优点
1. **逻辑正确**：按权重缺口分配USDT是合理的
2. **自然收敛**：多次rebalance会逐步逼近目标
3. **公平分配**：缺口大的资产获得更多预算
4. **防止过调**：已达标资产不会继续买入

### ⚠️ 局限性
1. **单次无法完全达标**：受滑点和舍入误差影响
2. **依赖多次迭代**：需要多次rebalance才能精确
3. **极端滑点下效果差**：但Core合约会拒绝执行

### ✅ 与Core合约配合
```
Core职责：
- 计算目标卖出/买入量
- 验证最终结果是否改善
- 拒绝损失过大的操作

Rebalancer职责：
- 执行swap，尽力完成
- 按权重缺口智能分配资金
- 不保证完美，但保证改善
```

## 最终建议

**✅ 采用这个算法，理由：**
1. 数学逻辑正确
2. 仿真验证通过
3. 与Core合约的验证层配合良好
4. 实现简单，易于审计

**改进建议：**
1. 在Phase 2重新获取权重（更精确）
2. 添加防御性检查（totalWeightDeficit == 0的情况）
3. 考虑添加最小买入量限制（避免dust amount）