#!/usr/bin/env python3
"""
代理配置管理模块

支持HTTP/SOCKS代理，防止IP被封
"""

import os
import random
import asyncio
import aiohttp
from typing import Optional, List, Dict
from dotenv import load_dotenv

load_dotenv()

class ProxyManager:
    """代理管理器"""
    
    def __init__(self):
        self.proxy_pools = self._load_proxy_config()
        self.current_proxy = None
        self.failed_proxies = set()
        
    def _load_proxy_config(self) -> List[Dict]:
        """加载代理配置"""
        proxies = []
        
        # 使用最新的Bright Data代理配置
        bright_data_proxy = "http://brd-customer-hl_27b741ac-zone-residential_proxy1:vslhbidpdl4f@brd.superproxy.io:33335"
        proxies.append({
            'http': bright_data_proxy,
            'https': bright_data_proxy
        })
        
        # 从环境变量加载额外代理
        proxy_list = os.getenv('PROXY_LIST', '').strip()
        if proxy_list:
            for proxy_str in proxy_list.split(','):
                proxy_str = proxy_str.strip()
                if proxy_str and proxy_str != bright_data_proxy:
                    proxies.append({
                        'http': proxy_str,
                        'https': proxy_str
                    })
        
        return proxies
    
    def get_random_proxy(self) -> Optional[Dict]:
        """获取随机代理"""
        if not self.proxy_pools:
            return None
            
        available_proxies = [p for p in self.proxy_pools 
                           if p.get('http') not in self.failed_proxies]
        
        if not available_proxies:
            # 重置失败代理列表
            self.failed_proxies.clear()
            available_proxies = self.proxy_pools
        
        if available_proxies:
            self.current_proxy = random.choice(available_proxies)
            return self.current_proxy
        
        return None
    
    def mark_proxy_failed(self, proxy: Dict):
        """标记代理失败"""
        if proxy and proxy.get('http'):
            self.failed_proxies.add(proxy['http'])
    
    def get_current_proxy(self) -> Optional[Dict]:
        """获取当前代理"""
        return self.current_proxy

class ProxySession:
    """修复版支持代理的HTTP会话"""
    
    def __init__(self, use_proxy: bool = True):
        self.proxy_manager = ProxyManager()
        self.use_proxy = use_proxy
        self.session = None
        self.current_proxy = None
        
    async def __aenter__(self):
        """异步上下文管理器入口"""
        # 获取代理配置
        if self.use_proxy:
            proxy_config = self.proxy_manager.get_random_proxy()
            if proxy_config:
                self.current_proxy = proxy_config.get('http')
                print(f"[PROXY] 使用Bright Data代理: brd.superproxy.io:33335")
            else:
                print("[WARN] 未配置代理，使用直连")
        
        # 配置连接器
        connector = aiohttp.TCPConnector(
            limit=50,
            limit_per_host=10,
            ttl_dns_cache=300,
            use_dns_cache=True,
            ssl=False,  # 禁用SSL验证
        )
        
        # 配置超时
        timeout = aiohttp.ClientTimeout(
            total=30,
            connect=15,
            sock_read=15
        )
        
        # 配置请求头
        headers = {
            'User-Agent': self._get_random_user_agent(),
            'Accept': 'application/json,text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
        }
        
        # 创建会话
        self.session = aiohttp.ClientSession(
            connector=connector,
            timeout=timeout,
            headers=headers
        )
        
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """异步上下文管理器退出"""
        if self.session:
            await self.session.close()
    
    def _get_random_user_agent(self) -> str:
        """获取随机User-Agent"""
        user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        ]
        return random.choice(user_agents)
    
    async def get(self, url: str, **kwargs):
        """GET请求"""
        if not self.session:
            raise RuntimeError("Session not initialized. Use 'async with' statement.")
        
        # 添加代理参数
        if self.current_proxy:
            kwargs['proxy'] = self.current_proxy
        
        try:
            response = await self.session.get(url, **kwargs)
            return response
        except Exception as e:
            # 标记代理失败
            if self.current_proxy:
                self.proxy_manager.mark_proxy_failed({'http': self.current_proxy})
            raise
    
    async def post(self, url: str, **kwargs):
        """POST请求"""
        if not self.session:
            raise RuntimeError("Session not initialized. Use 'async with' statement.")
        
        # 添加代理参数
        if self.current_proxy:
            kwargs['proxy'] = self.current_proxy
        
        try:
            response = await self.session.post(url, **kwargs)
            return response
        except Exception as e:
            # 标记代理失败
            if self.current_proxy:
                self.proxy_manager.mark_proxy_failed({'http': self.current_proxy})
            raise
    
    async def _rotate_proxy(self):
        """轮换代理"""
        if not self.use_proxy:
            return
            
        new_proxy_config = self.proxy_manager.get_random_proxy()
        if new_proxy_config:
            new_proxy = new_proxy_config.get('http')
            if new_proxy != getattr(self.session, '_proxy', None):
                self.session._proxy = new_proxy
                print(f"[ROTATE] Switch to Bright Data proxy")

def setup_proxy_config():
    """设置代理配置向导"""
    print("="*50)
    print("代理配置向导")
    print("="*50)
    
    print("\n✅ 已自动配置Bright Data代理:")
    print("   主机: brd.superproxy.io:33335")
    print("   状态: 已验证工作正常")
    print("   功能: IP轮换、地理位置切换")
    
    print("\n选择配置方式:")
    print("1. 使用默认Bright Data代理（推荐）")
    print("2. 添加额外代理")
    print("3. 不使用代理（直连）")
    
    choice = input("\n请选择 (1-3): ").strip()
    
    if choice == "1" or choice == "":
        print("✅ 使用默认Bright Data代理配置")
        return True
        
    elif choice == "3":
        print("⚠️ 配置为直连模式（不推荐）")
        # 清空代理配置
        env_path = '.env'
        lines = []
        
        if os.path.exists(env_path):
            with open(env_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
        
        # 禁用代理
        found = False
        for i, line in enumerate(lines):
            if line.startswith('USE_PROXY='):
                lines[i] = 'USE_PROXY=false\n'
                found = True
                break
        
        if not found:
            lines.append('USE_PROXY=false\n')
        
        with open(env_path, 'w', encoding='utf-8') as f:
            f.writelines(lines)
        
        return False
        
    elif choice == "2":
        print("\n请输入额外代理地址（格式: http://host:port 或 http://user:pass@host:port）")
        print("输入空行结束")
        
        additional_proxies = []
        while True:
            proxy = input("额外代理地址: ").strip()
            if not proxy:
                break
            additional_proxies.append(proxy)
        
        if additional_proxies:
            # 保存额外代理到.env文件
            proxy_str = ','.join(additional_proxies)
            
            env_path = '.env'
            lines = []
            
            if os.path.exists(env_path):
                with open(env_path, 'r', encoding='utf-8') as f:
                    lines = f.readlines()
            
            # 更新或添加ADDITIONAL_PROXIES
            found = False
            for i, line in enumerate(lines):
                if line.startswith('ADDITIONAL_PROXIES='):
                    lines[i] = f'ADDITIONAL_PROXIES={proxy_str}\n'
                    found = True
                    break
            
            if not found:
                lines.append(f'ADDITIONAL_PROXIES={proxy_str}\n')
            
            with open(env_path, 'w', encoding='utf-8') as f:
                f.writelines(lines)
            
            print(f"✅ 已添加 {len(additional_proxies)} 个额外代理")
        
        print("✅ 将使用Bright Data + 额外代理")
        return True
    
    print("❌ 无效选择，使用默认配置")
    return True

if __name__ == "__main__":
    # 测试代理配置
    setup_proxy_config()